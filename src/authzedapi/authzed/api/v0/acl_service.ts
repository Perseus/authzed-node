// @generated by protobuf-ts 2.0.7 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/v0/acl_service.proto" (package "authzed.api.v0", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RelationReference } from "./core";
import { RelationTupleTreeNode } from "./core";
import { User } from "./core";
import { RelationTupleUpdate } from "./core";
import { RelationTuple } from "./core";
import { Zookie } from "./core";
import { ObjectAndRelation } from "./core";
/**
 * @generated from protobuf message authzed.api.v0.RelationTupleFilter
 */
export interface RelationTupleFilter {
    /**
     * @generated from protobuf field: string namespace = 1;
     */
    namespace: string;
    /**
     * Setting any of these fields requires the appropriate filter type to be
     * added to the filters list as well
     *
     * @generated from protobuf field: string object_id = 2;
     */
    objectId: string;
    /**
     * @generated from protobuf field: string relation = 3;
     */
    relation: string;
    /**
     * @generated from protobuf field: authzed.api.v0.ObjectAndRelation userset = 5;
     */
    userset?: ObjectAndRelation;
    /**
     * @generated from protobuf field: repeated authzed.api.v0.RelationTupleFilter.Filter filters = 6;
     */
    filters: RelationTupleFilter_Filter[];
}
/**
 * @generated from protobuf enum authzed.api.v0.RelationTupleFilter.Filter
 */
export enum RelationTupleFilter_Filter {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: OBJECT_ID = 1;
     */
    OBJECT_ID = 1,
    /**
     * @generated from protobuf enum value: RELATION = 2;
     */
    RELATION = 2,
    /**
     * @generated from protobuf enum value: USERSET = 4;
     */
    USERSET = 4
}
/**
 * @generated from protobuf message authzed.api.v0.ReadRequest
 */
export interface ReadRequest {
    /**
     * A read request specifies one or multiple tuplesets and an optional zookie.
     *
     * @generated from protobuf field: repeated authzed.api.v0.RelationTupleFilter tuplesets = 1;
     */
    tuplesets: RelationTupleFilter[];
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie at_revision = 2;
     */
    atRevision?: Zookie;
}
/**
 * @generated from protobuf message authzed.api.v0.ReadResponse
 */
export interface ReadResponse {
    /**
     * @generated from protobuf field: repeated authzed.api.v0.ReadResponse.Tupleset tuplesets = 1;
     */
    tuplesets: ReadResponse_Tupleset[];
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie revision = 2;
     */
    revision?: Zookie;
}
/**
 * @generated from protobuf message authzed.api.v0.ReadResponse.Tupleset
 */
export interface ReadResponse_Tupleset {
    /**
     * @generated from protobuf field: repeated authzed.api.v0.RelationTuple tuples = 1;
     */
    tuples: RelationTuple[];
}
/**
 * @generated from protobuf message authzed.api.v0.WriteRequest
 */
export interface WriteRequest {
    /**
     * Clients may modify a single relation tuple to add or remove an ACL. They
     * may also modify all tuples related to an object via a read-modify-write
     * process with optimistic concurrency control [21] that uses a read RPC
     * followed by a write RPC:
     *
     * 1. Read all relation tuples of an object, including a per-object “lock”
     *    tuple.
     * 2. Generate the tuples to write or delete. Send the writes, along with a
     *    touch on the lock tuple, to Zanzibar, with the condition that the
     *    writes will be committed only if the lock tuple has not been modified
     *    since the read.
     * 3. If the write condition is not met, go back to step 1.
     *    The lock tuple is just a regular relation tuple used by clients to
     *    detect write races.
     *
     * The lock tuple is just a regular relation tuple used by clients to
     * detect write races.
     *
     * @generated from protobuf field: repeated authzed.api.v0.RelationTuple write_conditions = 1;
     */
    writeConditions: RelationTuple[]; // To be bounded by configuration
    /**
     * @generated from protobuf field: repeated authzed.api.v0.RelationTupleUpdate updates = 2;
     */
    updates: RelationTupleUpdate[];
}
/**
 * @generated from protobuf message authzed.api.v0.WriteResponse
 */
export interface WriteResponse {
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie revision = 1;
     */
    revision?: Zookie;
}
/**
 * @generated from protobuf message authzed.api.v0.CheckRequest
 */
export interface CheckRequest {
    /**
     * A check request specifies a userset, represented by ⟨object#relation⟩,
     * a putative user, often represented by an authentication token, and a
     * zookie corresponding to the desired object version.
     *
     * @generated from protobuf field: authzed.api.v0.ObjectAndRelation test_userset = 1;
     */
    testUserset?: ObjectAndRelation;
    /**
     * @generated from protobuf field: authzed.api.v0.User user = 2;
     */
    user?: User; // TODO swap for putative user
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie at_revision = 3;
     */
    atRevision?: Zookie;
}
/**
 * @generated from protobuf message authzed.api.v0.ContentChangeCheckRequest
 */
export interface ContentChangeCheckRequest {
    /**
     * To authorize application content modifications, our clients send a special
     * type of check request, a content-change check. A content-change check
     * request does not carry a zookie and is evaluated at the latest snapshot.
     *
     * @generated from protobuf field: authzed.api.v0.ObjectAndRelation test_userset = 1;
     */
    testUserset?: ObjectAndRelation;
    /**
     * @generated from protobuf field: authzed.api.v0.User user = 2;
     */
    user?: User; // TODO swap for a putative user
}
/**
 * @generated from protobuf message authzed.api.v0.CheckResponse
 */
export interface CheckResponse {
    /**
     * @generated from protobuf field: bool is_member = 1;
     */
    isMember: boolean;
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie revision = 2;
     */
    revision?: Zookie;
    /**
     * @generated from protobuf field: authzed.api.v0.CheckResponse.Membership membership = 3;
     */
    membership: CheckResponse_Membership;
}
/**
 * @generated from protobuf enum authzed.api.v0.CheckResponse.Membership
 */
export enum CheckResponse_Membership {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: NOT_MEMBER = 1;
     */
    NOT_MEMBER = 1,
    /**
     * @generated from protobuf enum value: MEMBER = 2;
     */
    MEMBER = 2
}
/**
 * @generated from protobuf message authzed.api.v0.ExpandRequest
 */
export interface ExpandRequest {
    /**
     * The Expand API returns the effective userset given an ⟨object#relation⟩
     * pair and an optional zookie. Unlike the Read API, Expand follows indirect
     * references expressed through userset rewrite rules.
     *
     * @generated from protobuf field: authzed.api.v0.ObjectAndRelation userset = 1;
     */
    userset?: ObjectAndRelation;
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie at_revision = 2;
     */
    atRevision?: Zookie;
}
/**
 * @generated from protobuf message authzed.api.v0.ExpandResponse
 */
export interface ExpandResponse {
    /**
     * The result is represented by a userset tree whose leaf nodes are user IDs
     * or usersets pointing to other ⟨object#relation⟩ pairs, and intermediate
     * nodes represent union, intersection, or exclusion operators.
     *
     * @generated from protobuf field: authzed.api.v0.RelationTupleTreeNode tree_node = 1;
     */
    treeNode?: RelationTupleTreeNode;
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie revision = 3;
     */
    revision?: Zookie;
}
/**
 * @generated from protobuf message authzed.api.v0.LookupRequest
 */
export interface LookupRequest {
    /**
     * @generated from protobuf field: authzed.api.v0.RelationReference object_relation = 1;
     */
    objectRelation?: RelationReference;
    /**
     * @generated from protobuf field: authzed.api.v0.ObjectAndRelation user = 2;
     */
    user?: ObjectAndRelation;
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie at_revision = 3;
     */
    atRevision?: Zookie;
    /**
     * @generated from protobuf field: string page_reference = 4;
     */
    pageReference: string;
    /**
     * @generated from protobuf field: uint32 limit = 5;
     */
    limit: number;
}
/**
 * @generated from protobuf message authzed.api.v0.LookupResponse
 */
export interface LookupResponse {
    /**
     * @generated from protobuf field: repeated string resolved_object_ids = 1;
     */
    resolvedObjectIds: string[];
    /**
     * @generated from protobuf field: string next_page_reference = 2;
     */
    nextPageReference: string;
    /**
     * @generated from protobuf field: authzed.api.v0.Zookie revision = 3;
     */
    revision?: Zookie;
}
// @generated message type with reflection information, may provide speed optimized methods
class RelationTupleFilter$Type extends MessageType<RelationTupleFilter> {
    constructor() {
        super("authzed.api.v0.RelationTupleFilter", [
            { no: 1, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{2,61}[a-z0-9]/)?[a-z][a-z0-9_]{2,62}[a-z0-9]$" } } } },
            { no: 2, name: "object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_][a-zA-Z0-9/_-]{0,127})?$" } } } },
            { no: 3, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{2,62}[a-z0-9])?$" } } } },
            { no: 5, name: "userset", kind: "message", T: () => ObjectAndRelation },
            { no: 6, name: "filters", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["authzed.api.v0.RelationTupleFilter.Filter", RelationTupleFilter_Filter], options: { "validate.rules": { repeated: { items: { enum: { definedOnly: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<RelationTupleFilter>): RelationTupleFilter {
        const message = { namespace: "", objectId: "", relation: "", filters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationTupleFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationTupleFilter): RelationTupleFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string namespace */ 1:
                    message.namespace = reader.string();
                    break;
                case /* string object_id */ 2:
                    message.objectId = reader.string();
                    break;
                case /* string relation */ 3:
                    message.relation = reader.string();
                    break;
                case /* authzed.api.v0.ObjectAndRelation userset */ 5:
                    message.userset = ObjectAndRelation.internalBinaryRead(reader, reader.uint32(), options, message.userset);
                    break;
                case /* repeated authzed.api.v0.RelationTupleFilter.Filter filters */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.filters.push(reader.int32());
                    else
                        message.filters.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationTupleFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string namespace = 1; */
        if (message.namespace !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.namespace);
        /* string object_id = 2; */
        if (message.objectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.objectId);
        /* string relation = 3; */
        if (message.relation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relation);
        /* authzed.api.v0.ObjectAndRelation userset = 5; */
        if (message.userset)
            ObjectAndRelation.internalBinaryWrite(message.userset, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v0.RelationTupleFilter.Filter filters = 6; */
        if (message.filters.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.filters.length; i++)
                writer.int32(message.filters[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.RelationTupleFilter
 */
export const RelationTupleFilter = new RelationTupleFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRequest$Type extends MessageType<ReadRequest> {
    constructor() {
        super("authzed.api.v0.ReadRequest", [
            { no: 1, name: "tuplesets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationTupleFilter, options: { "validate.rules": { repeated: { minItems: "1", items: { message: { required: true } } } } } },
            { no: 2, name: "at_revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<ReadRequest>): ReadRequest {
        const message = { tuplesets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRequest): ReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v0.RelationTupleFilter tuplesets */ 1:
                    message.tuplesets.push(RelationTupleFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v0.Zookie at_revision */ 2:
                    message.atRevision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.atRevision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v0.RelationTupleFilter tuplesets = 1; */
        for (let i = 0; i < message.tuplesets.length; i++)
            RelationTupleFilter.internalBinaryWrite(message.tuplesets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.Zookie at_revision = 2; */
        if (message.atRevision)
            Zookie.internalBinaryWrite(message.atRevision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.ReadRequest
 */
export const ReadRequest = new ReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadResponse$Type extends MessageType<ReadResponse> {
    constructor() {
        super("authzed.api.v0.ReadResponse", [
            { no: 1, name: "tuplesets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReadResponse_Tupleset },
            { no: 2, name: "revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<ReadResponse>): ReadResponse {
        const message = { tuplesets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadResponse): ReadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v0.ReadResponse.Tupleset tuplesets */ 1:
                    message.tuplesets.push(ReadResponse_Tupleset.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* authzed.api.v0.Zookie revision */ 2:
                    message.revision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v0.ReadResponse.Tupleset tuplesets = 1; */
        for (let i = 0; i < message.tuplesets.length; i++)
            ReadResponse_Tupleset.internalBinaryWrite(message.tuplesets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.Zookie revision = 2; */
        if (message.revision)
            Zookie.internalBinaryWrite(message.revision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.ReadResponse
 */
export const ReadResponse = new ReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadResponse_Tupleset$Type extends MessageType<ReadResponse_Tupleset> {
    constructor() {
        super("authzed.api.v0.ReadResponse.Tupleset", [
            { no: 1, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationTuple }
        ]);
    }
    create(value?: PartialMessage<ReadResponse_Tupleset>): ReadResponse_Tupleset {
        const message = { tuples: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadResponse_Tupleset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadResponse_Tupleset): ReadResponse_Tupleset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v0.RelationTuple tuples */ 1:
                    message.tuples.push(RelationTuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadResponse_Tupleset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v0.RelationTuple tuples = 1; */
        for (let i = 0; i < message.tuples.length; i++)
            RelationTuple.internalBinaryWrite(message.tuples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.ReadResponse.Tupleset
 */
export const ReadResponse_Tupleset = new ReadResponse_Tupleset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRequest$Type extends MessageType<WriteRequest> {
    constructor() {
        super("authzed.api.v0.WriteRequest", [
            { no: 1, name: "write_conditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationTuple, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } },
            { no: 2, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationTupleUpdate, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<WriteRequest>): WriteRequest {
        const message = { writeConditions: [], updates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRequest): WriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v0.RelationTuple write_conditions */ 1:
                    message.writeConditions.push(RelationTuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authzed.api.v0.RelationTupleUpdate updates */ 2:
                    message.updates.push(RelationTupleUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v0.RelationTuple write_conditions = 1; */
        for (let i = 0; i < message.writeConditions.length; i++)
            RelationTuple.internalBinaryWrite(message.writeConditions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v0.RelationTupleUpdate updates = 2; */
        for (let i = 0; i < message.updates.length; i++)
            RelationTupleUpdate.internalBinaryWrite(message.updates[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.WriteRequest
 */
export const WriteRequest = new WriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteResponse$Type extends MessageType<WriteResponse> {
    constructor() {
        super("authzed.api.v0.WriteResponse", [
            { no: 1, name: "revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<WriteResponse>): WriteResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteResponse): WriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v0.Zookie revision */ 1:
                    message.revision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v0.Zookie revision = 1; */
        if (message.revision)
            Zookie.internalBinaryWrite(message.revision, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.WriteResponse
 */
export const WriteResponse = new WriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckRequest$Type extends MessageType<CheckRequest> {
    constructor() {
        super("authzed.api.v0.CheckRequest", [
            { no: 1, name: "test_userset", kind: "message", T: () => ObjectAndRelation, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "user", kind: "message", T: () => User, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "at_revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<CheckRequest>): CheckRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckRequest): CheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v0.ObjectAndRelation test_userset */ 1:
                    message.testUserset = ObjectAndRelation.internalBinaryRead(reader, reader.uint32(), options, message.testUserset);
                    break;
                case /* authzed.api.v0.User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* authzed.api.v0.Zookie at_revision */ 3:
                    message.atRevision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.atRevision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v0.ObjectAndRelation test_userset = 1; */
        if (message.testUserset)
            ObjectAndRelation.internalBinaryWrite(message.testUserset, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.Zookie at_revision = 3; */
        if (message.atRevision)
            Zookie.internalBinaryWrite(message.atRevision, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.CheckRequest
 */
export const CheckRequest = new CheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContentChangeCheckRequest$Type extends MessageType<ContentChangeCheckRequest> {
    constructor() {
        super("authzed.api.v0.ContentChangeCheckRequest", [
            { no: 1, name: "test_userset", kind: "message", T: () => ObjectAndRelation, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "user", kind: "message", T: () => User, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ContentChangeCheckRequest>): ContentChangeCheckRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ContentChangeCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContentChangeCheckRequest): ContentChangeCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v0.ObjectAndRelation test_userset */ 1:
                    message.testUserset = ObjectAndRelation.internalBinaryRead(reader, reader.uint32(), options, message.testUserset);
                    break;
                case /* authzed.api.v0.User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContentChangeCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v0.ObjectAndRelation test_userset = 1; */
        if (message.testUserset)
            ObjectAndRelation.internalBinaryWrite(message.testUserset, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.ContentChangeCheckRequest
 */
export const ContentChangeCheckRequest = new ContentChangeCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckResponse$Type extends MessageType<CheckResponse> {
    constructor() {
        super("authzed.api.v0.CheckResponse", [
            { no: 1, name: "is_member", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "revision", kind: "message", T: () => Zookie },
            { no: 3, name: "membership", kind: "enum", T: () => ["authzed.api.v0.CheckResponse.Membership", CheckResponse_Membership] }
        ]);
    }
    create(value?: PartialMessage<CheckResponse>): CheckResponse {
        const message = { isMember: false, membership: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckResponse): CheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_member */ 1:
                    message.isMember = reader.bool();
                    break;
                case /* authzed.api.v0.Zookie revision */ 2:
                    message.revision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                case /* authzed.api.v0.CheckResponse.Membership membership */ 3:
                    message.membership = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_member = 1; */
        if (message.isMember !== false)
            writer.tag(1, WireType.Varint).bool(message.isMember);
        /* authzed.api.v0.Zookie revision = 2; */
        if (message.revision)
            Zookie.internalBinaryWrite(message.revision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.CheckResponse.Membership membership = 3; */
        if (message.membership !== 0)
            writer.tag(3, WireType.Varint).int32(message.membership);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.CheckResponse
 */
export const CheckResponse = new CheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandRequest$Type extends MessageType<ExpandRequest> {
    constructor() {
        super("authzed.api.v0.ExpandRequest", [
            { no: 1, name: "userset", kind: "message", T: () => ObjectAndRelation, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "at_revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<ExpandRequest>): ExpandRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandRequest): ExpandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v0.ObjectAndRelation userset */ 1:
                    message.userset = ObjectAndRelation.internalBinaryRead(reader, reader.uint32(), options, message.userset);
                    break;
                case /* authzed.api.v0.Zookie at_revision */ 2:
                    message.atRevision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.atRevision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v0.ObjectAndRelation userset = 1; */
        if (message.userset)
            ObjectAndRelation.internalBinaryWrite(message.userset, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.Zookie at_revision = 2; */
        if (message.atRevision)
            Zookie.internalBinaryWrite(message.atRevision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.ExpandRequest
 */
export const ExpandRequest = new ExpandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandResponse$Type extends MessageType<ExpandResponse> {
    constructor() {
        super("authzed.api.v0.ExpandResponse", [
            { no: 1, name: "tree_node", kind: "message", T: () => RelationTupleTreeNode },
            { no: 3, name: "revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<ExpandResponse>): ExpandResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandResponse): ExpandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v0.RelationTupleTreeNode tree_node */ 1:
                    message.treeNode = RelationTupleTreeNode.internalBinaryRead(reader, reader.uint32(), options, message.treeNode);
                    break;
                case /* authzed.api.v0.Zookie revision */ 3:
                    message.revision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v0.RelationTupleTreeNode tree_node = 1; */
        if (message.treeNode)
            RelationTupleTreeNode.internalBinaryWrite(message.treeNode, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.Zookie revision = 3; */
        if (message.revision)
            Zookie.internalBinaryWrite(message.revision, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.ExpandResponse
 */
export const ExpandResponse = new ExpandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupRequest$Type extends MessageType<LookupRequest> {
    constructor() {
        super("authzed.api.v0.LookupRequest", [
            { no: 1, name: "object_relation", kind: "message", T: () => RelationReference },
            { no: 2, name: "user", kind: "message", T: () => ObjectAndRelation },
            { no: 3, name: "at_revision", kind: "message", T: () => Zookie },
            { no: 4, name: "page_reference", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LookupRequest>): LookupRequest {
        const message = { pageReference: "", limit: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupRequest): LookupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v0.RelationReference object_relation */ 1:
                    message.objectRelation = RelationReference.internalBinaryRead(reader, reader.uint32(), options, message.objectRelation);
                    break;
                case /* authzed.api.v0.ObjectAndRelation user */ 2:
                    message.user = ObjectAndRelation.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* authzed.api.v0.Zookie at_revision */ 3:
                    message.atRevision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.atRevision);
                    break;
                case /* string page_reference */ 4:
                    message.pageReference = reader.string();
                    break;
                case /* uint32 limit */ 5:
                    message.limit = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v0.RelationReference object_relation = 1; */
        if (message.objectRelation)
            RelationReference.internalBinaryWrite(message.objectRelation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.ObjectAndRelation user = 2; */
        if (message.user)
            ObjectAndRelation.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v0.Zookie at_revision = 3; */
        if (message.atRevision)
            Zookie.internalBinaryWrite(message.atRevision, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string page_reference = 4; */
        if (message.pageReference !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.pageReference);
        /* uint32 limit = 5; */
        if (message.limit !== 0)
            writer.tag(5, WireType.Varint).uint32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.LookupRequest
 */
export const LookupRequest = new LookupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResponse$Type extends MessageType<LookupResponse> {
    constructor() {
        super("authzed.api.v0.LookupResponse", [
            { no: 1, name: "resolved_object_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "next_page_reference", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "revision", kind: "message", T: () => Zookie }
        ]);
    }
    create(value?: PartialMessage<LookupResponse>): LookupResponse {
        const message = { resolvedObjectIds: [], nextPageReference: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupResponse): LookupResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string resolved_object_ids */ 1:
                    message.resolvedObjectIds.push(reader.string());
                    break;
                case /* string next_page_reference */ 2:
                    message.nextPageReference = reader.string();
                    break;
                case /* authzed.api.v0.Zookie revision */ 3:
                    message.revision = Zookie.internalBinaryRead(reader, reader.uint32(), options, message.revision);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string resolved_object_ids = 1; */
        for (let i = 0; i < message.resolvedObjectIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.resolvedObjectIds[i]);
        /* string next_page_reference = 2; */
        if (message.nextPageReference !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageReference);
        /* authzed.api.v0.Zookie revision = 3; */
        if (message.revision)
            Zookie.internalBinaryWrite(message.revision, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v0.LookupResponse
 */
export const LookupResponse = new LookupResponse$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v0.ACLService
 */
export const ACLService = new ServiceType("authzed.api.v0.ACLService", [
    { name: "Read", options: {}, I: ReadRequest, O: ReadResponse },
    { name: "Write", options: {}, I: WriteRequest, O: WriteResponse },
    { name: "Check", options: {}, I: CheckRequest, O: CheckResponse },
    { name: "ContentChangeCheck", options: {}, I: ContentChangeCheckRequest, O: CheckResponse },
    { name: "Expand", options: {}, I: ExpandRequest, O: ExpandResponse },
    { name: "Lookup", options: {}, I: LookupRequest, O: LookupResponse }
]);
