// @generated by protobuf-ts 2.0.7 with parameter generate_dependencies,long_type_string,client_grpc1
// @generated from protobuf file "authzed/api/v1/permission_service.proto" (package "authzed.api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PermissionRelationshipTree } from "./core";
import { SubjectReference } from "./core";
import { ObjectReference } from "./core";
import { RelationshipUpdate } from "./core";
import { Relationship } from "./core";
import { ZedToken } from "./core";
/**
 * Consistency will define how a request is handled by the backend.
 * By defining a consistency requirement, and a token at which those
 * requirements should be applied, where applicable.
 *
 * @generated from protobuf message authzed.api.v1.Consistency
 */
export interface Consistency {
    /**
     * @generated from protobuf oneof: requirement
     */
    requirement: {
        oneofKind: "minimizeLatency";
        /**
         * minimize_latency indicates that the latency for the call should be
         * minimized by having the system select the fastest snapshot available.
         *
         * @generated from protobuf field: bool minimize_latency = 1;
         */
        minimizeLatency: boolean;
    } | {
        oneofKind: "atLeastAsFresh";
        /**
         * at_least_as_fresh indicates that all data used in the API call must be
         * *at least as fresh* as that found in the ZedToken; more recent data might
         * be used if available or faster.
         *
         * @generated from protobuf field: authzed.api.v1.ZedToken at_least_as_fresh = 2;
         */
        atLeastAsFresh: ZedToken;
    } | {
        oneofKind: "atExactSnapshot";
        /**
         * at_exact_snapshot indicates that all data used in the API call must be
         * *at the given* snapshot in time; if the snapshot is no longer available,
         * an error will be returned to the caller.
         *
         * @generated from protobuf field: authzed.api.v1.ZedToken at_exact_snapshot = 3;
         */
        atExactSnapshot: ZedToken;
    } | {
        oneofKind: "fullyConsistent";
        /**
         * fully_consistent indicates that all data used in the API call *must* be
         * at the most recent snapshot found.
         *
         * NOTE: using this method can be *quite slow*, so unless there is a need to
         * do so, it is recommended to use `at_least_as_fresh` with a stored
         * ZedToken.
         *
         * @generated from protobuf field: bool fully_consistent = 4;
         */
        fullyConsistent: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * RelationshipFilter is a collection of filters which when applied to a
 * relationship will return relationships that have exactly matching fields.
 *
 * resource_type is required. All other fields are optional and if left
 * unspecified will not filter relationships.
 *
 * @generated from protobuf message authzed.api.v1.RelationshipFilter
 */
export interface RelationshipFilter {
    /**
     * @generated from protobuf field: string resource_type = 1;
     */
    resourceType: string;
    /**
     * @generated from protobuf field: string optional_resource_id = 2;
     */
    optionalResourceId: string;
    /**
     * @generated from protobuf field: string optional_relation = 3;
     */
    optionalRelation: string;
    /**
     * @generated from protobuf field: authzed.api.v1.SubjectFilter optional_subject_filter = 4;
     */
    optionalSubjectFilter?: SubjectFilter;
}
/**
 * SubjectFilter specifies a filter on the subject of a relationship.
 *
 * subject_type is required and all other fields are optional, and will not
 * impose any additional requirements if left unspecified.
 *
 * @generated from protobuf message authzed.api.v1.SubjectFilter
 */
export interface SubjectFilter {
    /**
     * @generated from protobuf field: string subject_type = 1;
     */
    subjectType: string;
    /**
     * @generated from protobuf field: string optional_subject_id = 2;
     */
    optionalSubjectId: string;
    /**
     * @generated from protobuf field: authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3;
     */
    optionalRelation?: SubjectFilter_RelationFilter;
}
/**
 * @generated from protobuf message authzed.api.v1.SubjectFilter.RelationFilter
 */
export interface SubjectFilter_RelationFilter {
    /**
     * @generated from protobuf field: string relation = 1;
     */
    relation: string;
}
/**
 * ReadRelationshipsRequest specifies one or more filters used to read matching
 * relationships within the system.
 *
 * @generated from protobuf message authzed.api.v1.ReadRelationshipsRequest
 */
export interface ReadRelationshipsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter relationship_filter = 2;
     */
    relationshipFilter?: RelationshipFilter;
}
/**
 * ReadRelationshipsResponse contains a Relationship found that matches the
 * specified relationship filter(s). A instance of this response message will
 * be streamed to the client for each relationship found.
 *
 * @generated from protobuf message authzed.api.v1.ReadRelationshipsResponse
 */
export interface ReadRelationshipsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken read_at = 1;
     */
    readAt?: ZedToken;
    /**
     * @generated from protobuf field: authzed.api.v1.Relationship relationship = 2;
     */
    relationship?: Relationship;
}
/**
 * Precondition specifies how and the existence or absence of certain
 * relationships as expressed through the accompanying filter should affect
 * whether or not the operation proceeds.
 *
 * MUST_NOT_MATCH will fail the parent request if any relationships match the
 * relationships filter.
 * MUST_MATCH will fail the parent request if there are no
 * relationships that match the filter.
 *
 * @generated from protobuf message authzed.api.v1.Precondition
 */
export interface Precondition {
    /**
     * @generated from protobuf field: authzed.api.v1.Precondition.Operation operation = 1;
     */
    operation: Precondition_Operation;
    /**
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter filter = 2;
     */
    filter?: RelationshipFilter;
}
/**
 * @generated from protobuf enum authzed.api.v1.Precondition.Operation
 */
export enum Precondition_Operation {
    /**
     * @generated from protobuf enum value: OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: OPERATION_MUST_NOT_MATCH = 1;
     */
    MUST_NOT_MATCH = 1,
    /**
     * @generated from protobuf enum value: OPERATION_MUST_MATCH = 2;
     */
    MUST_MATCH = 2
}
/**
 * WriteRelationshipsRequest contains a list of Relationship mutations that
 * should be applied to the service. If the optional_preconditions parameter
 * is included, all of the specified preconditions must also be satisfied before
 * the write will be committed.
 *
 * @generated from protobuf message authzed.api.v1.WriteRelationshipsRequest
 */
export interface WriteRelationshipsRequest {
    /**
     * @generated from protobuf field: repeated authzed.api.v1.RelationshipUpdate updates = 1;
     */
    updates: RelationshipUpdate[];
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Precondition optional_preconditions = 2;
     */
    optionalPreconditions: Precondition[]; // To be bounded by configuration
}
/**
 * @generated from protobuf message authzed.api.v1.WriteRelationshipsResponse
 */
export interface WriteRelationshipsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken written_at = 1;
     */
    writtenAt?: ZedToken;
}
/**
 * DeleteRelationshipsRequest specifies which Relationships should be deleted,
 * requesting the delete of *ALL* relationships that match the specified
 * filters. If the optional_preconditions parameter is included, all of the
 * specified preconditions must also be satisfied before the delete will be
 * executed.
 *
 * @generated from protobuf message authzed.api.v1.DeleteRelationshipsRequest
 */
export interface DeleteRelationshipsRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.RelationshipFilter relationship_filter = 1;
     */
    relationshipFilter?: RelationshipFilter;
    /**
     * @generated from protobuf field: repeated authzed.api.v1.Precondition optional_preconditions = 2;
     */
    optionalPreconditions: Precondition[]; // To be bounded by configuration
}
/**
 * @generated from protobuf message authzed.api.v1.DeleteRelationshipsResponse
 */
export interface DeleteRelationshipsResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken deleted_at = 1;
     */
    deletedAt?: ZedToken;
}
/**
 * CheckPermissionRequest issues a check on whether a subject has a permission
 * or is a member of a relation, on a specific resource.
 *
 * @generated from protobuf message authzed.api.v1.CheckPermissionRequest
 */
export interface CheckPermissionRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource is the resource on which to check the permission or relation.
     *
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 2;
     */
    resource?: ObjectReference;
    /**
     * permission is the name of the permission (or relation) on which to execute
     * the check.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
    /**
     * subject is the subject that will be checked for the permission or relation.
     *
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 4;
     */
    subject?: SubjectReference;
}
/**
 * @generated from protobuf message authzed.api.v1.CheckPermissionResponse
 */
export interface CheckPermissionResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken checked_at = 1;
     */
    checkedAt?: ZedToken;
    /**
     * Permissionship communicates whether or not the subject has the requested
     * permission or has a relationship with the given resource, over the given
     * relation.
     *
     * This value will be authzed.api.v1.PERMISSIONSHIP_HAS_PERMISSION if the
     * requested subject is a member of the computed permission set or there
     * exists a relationship with the requested relation from the given resource
     * to the given subject.
     *
     * @generated from protobuf field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2;
     */
    permissionship: CheckPermissionResponse_Permissionship;
}
/**
 * @generated from protobuf enum authzed.api.v1.CheckPermissionResponse.Permissionship
 */
export enum CheckPermissionResponse_Permissionship {
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_NO_PERMISSION = 1;
     */
    NO_PERMISSION = 1,
    /**
     * @generated from protobuf enum value: PERMISSIONSHIP_HAS_PERMISSION = 2;
     */
    HAS_PERMISSION = 2
}
/**
 * ExpandPermissionTreeRequest returns a tree representing the expansion of all
 * relationships found accessible from a permission or relation on a particular
 * resource.
 *
 * ExpandPermissionTreeRequest is typically used to determine the full set of
 * subjects with a permission, along with the relationships that grant said
 * access.
 *
 * @generated from protobuf message authzed.api.v1.ExpandPermissionTreeRequest
 */
export interface ExpandPermissionTreeRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource is the resource over which to run the expansion.
     *
     * @generated from protobuf field: authzed.api.v1.ObjectReference resource = 2;
     */
    resource?: ObjectReference;
    /**
     * permission is the name of the permission or relation over which to run the
     * expansion for the resource.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
}
/**
 * @generated from protobuf message authzed.api.v1.ExpandPermissionTreeResponse
 */
export interface ExpandPermissionTreeResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken expanded_at = 1;
     */
    expandedAt?: ZedToken;
    /**
     * tree_root is a tree structure whose leaf nodes are subjects, and
     * intermediate nodes represent the various operations (union, intersection,
     * exclusion) to reach those subjects.
     *
     * @generated from protobuf field: authzed.api.v1.PermissionRelationshipTree tree_root = 2;
     */
    treeRoot?: PermissionRelationshipTree;
}
/**
 * LookupResourcesRequest performs a lookup of all resources of a particular
 * kind on which the subject has the specified permission or the relation in
 * which the subject exists, streaming back the IDs of those resources.
 *
 * @generated from protobuf message authzed.api.v1.LookupResourcesRequest
 */
export interface LookupResourcesRequest {
    /**
     * @generated from protobuf field: authzed.api.v1.Consistency consistency = 1;
     */
    consistency?: Consistency;
    /**
     * resource_object_type is the type of resource object for which the IDs will
     * be returned.
     *
     * @generated from protobuf field: string resource_object_type = 2;
     */
    resourceObjectType: string;
    /**
     * permission is the name of the permission or relation for which the subject
     * must Check.
     *
     * @generated from protobuf field: string permission = 3;
     */
    permission: string;
    /**
     * subject is the subject with access to the resources.
     *
     * @generated from protobuf field: authzed.api.v1.SubjectReference subject = 4;
     */
    subject?: SubjectReference;
}
/**
 * LookupResourcesResponse contains a single matching resource object ID for the
 * requested object type, permission, and subject.
 *
 * @generated from protobuf message authzed.api.v1.LookupResourcesResponse
 */
export interface LookupResourcesResponse {
    /**
     * @generated from protobuf field: authzed.api.v1.ZedToken looked_up_at = 1;
     */
    lookedUpAt?: ZedToken;
    /**
     * @generated from protobuf field: string resource_object_id = 2;
     */
    resourceObjectId: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Consistency$Type extends MessageType<Consistency> {
    constructor() {
        super("authzed.api.v1.Consistency", [
            { no: 1, name: "minimize_latency", kind: "scalar", oneof: "requirement", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } },
            { no: 2, name: "at_least_as_fresh", kind: "message", oneof: "requirement", T: () => ZedToken },
            { no: 3, name: "at_exact_snapshot", kind: "message", oneof: "requirement", T: () => ZedToken },
            { no: 4, name: "fully_consistent", kind: "scalar", oneof: "requirement", T: 8 /*ScalarType.BOOL*/, options: { "validate.rules": { bool: { const: true } } } }
        ]);
    }
    create(value?: PartialMessage<Consistency>): Consistency {
        const message = { requirement: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Consistency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Consistency): Consistency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool minimize_latency */ 1:
                    message.requirement = {
                        oneofKind: "minimizeLatency",
                        minimizeLatency: reader.bool()
                    };
                    break;
                case /* authzed.api.v1.ZedToken at_least_as_fresh */ 2:
                    message.requirement = {
                        oneofKind: "atLeastAsFresh",
                        atLeastAsFresh: ZedToken.internalBinaryRead(reader, reader.uint32(), options, (message.requirement as any).atLeastAsFresh)
                    };
                    break;
                case /* authzed.api.v1.ZedToken at_exact_snapshot */ 3:
                    message.requirement = {
                        oneofKind: "atExactSnapshot",
                        atExactSnapshot: ZedToken.internalBinaryRead(reader, reader.uint32(), options, (message.requirement as any).atExactSnapshot)
                    };
                    break;
                case /* bool fully_consistent */ 4:
                    message.requirement = {
                        oneofKind: "fullyConsistent",
                        fullyConsistent: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Consistency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool minimize_latency = 1; */
        if (message.requirement.oneofKind === "minimizeLatency")
            writer.tag(1, WireType.Varint).bool(message.requirement.minimizeLatency);
        /* authzed.api.v1.ZedToken at_least_as_fresh = 2; */
        if (message.requirement.oneofKind === "atLeastAsFresh")
            ZedToken.internalBinaryWrite(message.requirement.atLeastAsFresh, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ZedToken at_exact_snapshot = 3; */
        if (message.requirement.oneofKind === "atExactSnapshot")
            ZedToken.internalBinaryWrite(message.requirement.atExactSnapshot, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool fully_consistent = 4; */
        if (message.requirement.oneofKind === "fullyConsistent")
            writer.tag(4, WireType.Varint).bool(message.requirement.fullyConsistent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.Consistency
 */
export const Consistency = new Consistency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipFilter$Type extends MessageType<RelationshipFilter> {
    constructor() {
        super("authzed.api.v1.RelationshipFilter", [
            { no: 1, name: "resource_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 2, name: "optional_resource_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_][a-zA-Z0-9/_|-]{0,127})?$" } } } },
            { no: 3, name: "optional_relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "optional_subject_filter", kind: "message", T: () => SubjectFilter }
        ]);
    }
    create(value?: PartialMessage<RelationshipFilter>): RelationshipFilter {
        const message = { resourceType: "", optionalResourceId: "", optionalRelation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipFilter): RelationshipFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string resource_type */ 1:
                    message.resourceType = reader.string();
                    break;
                case /* string optional_resource_id */ 2:
                    message.optionalResourceId = reader.string();
                    break;
                case /* string optional_relation */ 3:
                    message.optionalRelation = reader.string();
                    break;
                case /* authzed.api.v1.SubjectFilter optional_subject_filter */ 4:
                    message.optionalSubjectFilter = SubjectFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalSubjectFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string resource_type = 1; */
        if (message.resourceType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.resourceType);
        /* string optional_resource_id = 2; */
        if (message.optionalResourceId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalResourceId);
        /* string optional_relation = 3; */
        if (message.optionalRelation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.optionalRelation);
        /* authzed.api.v1.SubjectFilter optional_subject_filter = 4; */
        if (message.optionalSubjectFilter)
            SubjectFilter.internalBinaryWrite(message.optionalSubjectFilter, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.RelationshipFilter
 */
export const RelationshipFilter = new RelationshipFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter$Type extends MessageType<SubjectFilter> {
    constructor() {
        super("authzed.api.v1.SubjectFilter", [
            { no: 1, name: "subject_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 2, name: "optional_subject_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^(([a-zA-Z0-9_][a-zA-Z0-9/_|-]{0,127})|\\*)?$" } } } },
            { no: 3, name: "optional_relation", kind: "message", T: () => SubjectFilter_RelationFilter }
        ]);
    }
    create(value?: PartialMessage<SubjectFilter>): SubjectFilter {
        const message = { subjectType: "", optionalSubjectId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubjectFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubjectFilter): SubjectFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string subject_type */ 1:
                    message.subjectType = reader.string();
                    break;
                case /* string optional_subject_id */ 2:
                    message.optionalSubjectId = reader.string();
                    break;
                case /* authzed.api.v1.SubjectFilter.RelationFilter optional_relation */ 3:
                    message.optionalRelation = SubjectFilter_RelationFilter.internalBinaryRead(reader, reader.uint32(), options, message.optionalRelation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubjectFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string subject_type = 1; */
        if (message.subjectType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.subjectType);
        /* string optional_subject_id = 2; */
        if (message.optionalSubjectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.optionalSubjectId);
        /* authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3; */
        if (message.optionalRelation)
            SubjectFilter_RelationFilter.internalBinaryWrite(message.optionalRelation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.SubjectFilter
 */
export const SubjectFilter = new SubjectFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter_RelationFilter$Type extends MessageType<SubjectFilter_RelationFilter> {
    constructor() {
        super("authzed.api.v1.SubjectFilter.RelationFilter", [
            { no: 1, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value?: PartialMessage<SubjectFilter_RelationFilter>): SubjectFilter_RelationFilter {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubjectFilter_RelationFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubjectFilter_RelationFilter): SubjectFilter_RelationFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relation */ 1:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubjectFilter_RelationFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relation = 1; */
        if (message.relation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.SubjectFilter.RelationFilter
 */
export const SubjectFilter_RelationFilter = new SubjectFilter_RelationFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRelationshipsRequest$Type extends MessageType<ReadRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.ReadRelationshipsRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "relationship_filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<ReadRelationshipsRequest>): ReadRelationshipsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRelationshipsRequest): ReadRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 2:
                    message.relationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.RelationshipFilter relationship_filter = 2; */
        if (message.relationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadRelationshipsRequest
 */
export const ReadRelationshipsRequest = new ReadRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRelationshipsResponse$Type extends MessageType<ReadRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.ReadRelationshipsResponse", [
            { no: 1, name: "read_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "relationship", kind: "message", T: () => Relationship }
        ]);
    }
    create(value?: PartialMessage<ReadRelationshipsResponse>): ReadRelationshipsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRelationshipsResponse): ReadRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken read_at */ 1:
                    message.readAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.readAt);
                    break;
                case /* authzed.api.v1.Relationship relationship */ 2:
                    message.relationship = Relationship.internalBinaryRead(reader, reader.uint32(), options, message.relationship);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken read_at = 1; */
        if (message.readAt)
            ZedToken.internalBinaryWrite(message.readAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.Relationship relationship = 2; */
        if (message.relationship)
            Relationship.internalBinaryWrite(message.relationship, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ReadRelationshipsResponse
 */
export const ReadRelationshipsResponse = new ReadRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Precondition$Type extends MessageType<Precondition> {
    constructor() {
        super("authzed.api.v1.Precondition", [
            { no: 1, name: "operation", kind: "enum", T: () => ["authzed.api.v1.Precondition.Operation", Precondition_Operation, "OPERATION_"], options: { "validate.rules": { enum: { definedOnly: true } } } },
            { no: 2, name: "filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Precondition>): Precondition {
        const message = { operation: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Precondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Precondition): Precondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Precondition.Operation operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* authzed.api.v1.RelationshipFilter filter */ 2:
                    message.filter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Precondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Precondition.Operation operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation);
        /* authzed.api.v1.RelationshipFilter filter = 2; */
        if (message.filter)
            RelationshipFilter.internalBinaryWrite(message.filter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.Precondition
 */
export const Precondition = new Precondition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRelationshipsRequest$Type extends MessageType<WriteRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.WriteRelationshipsRequest", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationshipUpdate, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } },
            { no: 2, name: "optional_preconditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Precondition, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<WriteRelationshipsRequest>): WriteRelationshipsRequest {
        const message = { updates: [], optionalPreconditions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRelationshipsRequest): WriteRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated authzed.api.v1.RelationshipUpdate updates */ 1:
                    message.updates.push(RelationshipUpdate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated authzed.api.v1.Precondition optional_preconditions */ 2:
                    message.optionalPreconditions.push(Precondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated authzed.api.v1.RelationshipUpdate updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            RelationshipUpdate.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Precondition optional_preconditions = 2; */
        for (let i = 0; i < message.optionalPreconditions.length; i++)
            Precondition.internalBinaryWrite(message.optionalPreconditions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteRelationshipsRequest
 */
export const WriteRelationshipsRequest = new WriteRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRelationshipsResponse$Type extends MessageType<WriteRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.WriteRelationshipsResponse", [
            { no: 1, name: "written_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<WriteRelationshipsResponse>): WriteRelationshipsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRelationshipsResponse): WriteRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken written_at */ 1:
                    message.writtenAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.writtenAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken written_at = 1; */
        if (message.writtenAt)
            ZedToken.internalBinaryWrite(message.writtenAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.WriteRelationshipsResponse
 */
export const WriteRelationshipsResponse = new WriteRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRelationshipsRequest$Type extends MessageType<DeleteRelationshipsRequest> {
    constructor() {
        super("authzed.api.v1.DeleteRelationshipsRequest", [
            { no: 1, name: "relationship_filter", kind: "message", T: () => RelationshipFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "optional_preconditions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Precondition, options: { "validate.rules": { repeated: { items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<DeleteRelationshipsRequest>): DeleteRelationshipsRequest {
        const message = { optionalPreconditions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteRelationshipsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRelationshipsRequest): DeleteRelationshipsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.RelationshipFilter relationship_filter */ 1:
                    message.relationshipFilter = RelationshipFilter.internalBinaryRead(reader, reader.uint32(), options, message.relationshipFilter);
                    break;
                case /* repeated authzed.api.v1.Precondition optional_preconditions */ 2:
                    message.optionalPreconditions.push(Precondition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRelationshipsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.RelationshipFilter relationship_filter = 1; */
        if (message.relationshipFilter)
            RelationshipFilter.internalBinaryWrite(message.relationshipFilter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated authzed.api.v1.Precondition optional_preconditions = 2; */
        for (let i = 0; i < message.optionalPreconditions.length; i++)
            Precondition.internalBinaryWrite(message.optionalPreconditions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.DeleteRelationshipsRequest
 */
export const DeleteRelationshipsRequest = new DeleteRelationshipsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRelationshipsResponse$Type extends MessageType<DeleteRelationshipsResponse> {
    constructor() {
        super("authzed.api.v1.DeleteRelationshipsResponse", [
            { no: 1, name: "deleted_at", kind: "message", T: () => ZedToken }
        ]);
    }
    create(value?: PartialMessage<DeleteRelationshipsResponse>): DeleteRelationshipsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteRelationshipsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRelationshipsResponse): DeleteRelationshipsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken deleted_at */ 1:
                    message.deletedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.deletedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRelationshipsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken deleted_at = 1; */
        if (message.deletedAt)
            ZedToken.internalBinaryWrite(message.deletedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.DeleteRelationshipsResponse
 */
export const DeleteRelationshipsResponse = new DeleteRelationshipsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionRequest$Type extends MessageType<CheckPermissionRequest> {
    constructor() {
        super("authzed.api.v1.CheckPermissionRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } },
            { no: 4, name: "subject", kind: "message", T: () => SubjectReference, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<CheckPermissionRequest>): CheckPermissionRequest {
        const message = { permission: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckPermissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPermissionRequest): CheckPermissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPermissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckPermissionRequest
 */
export const CheckPermissionRequest = new CheckPermissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckPermissionResponse$Type extends MessageType<CheckPermissionResponse> {
    constructor() {
        super("authzed.api.v1.CheckPermissionResponse", [
            { no: 1, name: "checked_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "permissionship", kind: "enum", T: () => ["authzed.api.v1.CheckPermissionResponse.Permissionship", CheckPermissionResponse_Permissionship, "PERMISSIONSHIP_"] }
        ]);
    }
    create(value?: PartialMessage<CheckPermissionResponse>): CheckPermissionResponse {
        const message = { permissionship: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CheckPermissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckPermissionResponse): CheckPermissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken checked_at */ 1:
                    message.checkedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.checkedAt);
                    break;
                case /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship */ 2:
                    message.permissionship = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckPermissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken checked_at = 1; */
        if (message.checkedAt)
            ZedToken.internalBinaryWrite(message.checkedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2; */
        if (message.permissionship !== 0)
            writer.tag(2, WireType.Varint).int32(message.permissionship);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.CheckPermissionResponse
 */
export const CheckPermissionResponse = new CheckPermissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandPermissionTreeRequest$Type extends MessageType<ExpandPermissionTreeRequest> {
    constructor() {
        super("authzed.api.v1.ExpandPermissionTreeRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource", kind: "message", T: () => ObjectReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^([a-z][a-z0-9_]{1,62}[a-z0-9])?$" } } } }
        ]);
    }
    create(value?: PartialMessage<ExpandPermissionTreeRequest>): ExpandPermissionTreeRequest {
        const message = { permission: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandPermissionTreeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandPermissionTreeRequest): ExpandPermissionTreeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* authzed.api.v1.ObjectReference resource */ 2:
                    message.resource = ObjectReference.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandPermissionTreeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.ObjectReference resource = 2; */
        if (message.resource)
            ObjectReference.internalBinaryWrite(message.resource, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpandPermissionTreeRequest
 */
export const ExpandPermissionTreeRequest = new ExpandPermissionTreeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandPermissionTreeResponse$Type extends MessageType<ExpandPermissionTreeResponse> {
    constructor() {
        super("authzed.api.v1.ExpandPermissionTreeResponse", [
            { no: 1, name: "expanded_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "tree_root", kind: "message", T: () => PermissionRelationshipTree }
        ]);
    }
    create(value?: PartialMessage<ExpandPermissionTreeResponse>): ExpandPermissionTreeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandPermissionTreeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandPermissionTreeResponse): ExpandPermissionTreeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken expanded_at */ 1:
                    message.expandedAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.expandedAt);
                    break;
                case /* authzed.api.v1.PermissionRelationshipTree tree_root */ 2:
                    message.treeRoot = PermissionRelationshipTree.internalBinaryRead(reader, reader.uint32(), options, message.treeRoot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandPermissionTreeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken expanded_at = 1; */
        if (message.expandedAt)
            ZedToken.internalBinaryWrite(message.expandedAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* authzed.api.v1.PermissionRelationshipTree tree_root = 2; */
        if (message.treeRoot)
            PermissionRelationshipTree.internalBinaryWrite(message.treeRoot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.ExpandPermissionTreeResponse
 */
export const ExpandPermissionTreeResponse = new ExpandPermissionTreeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResourcesRequest$Type extends MessageType<LookupResourcesRequest> {
    constructor() {
        super("authzed.api.v1.LookupResourcesRequest", [
            { no: 1, name: "consistency", kind: "message", T: () => Consistency },
            { no: 2, name: "resource_object_type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 3, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-z][a-z0-9_]{1,62}[a-z0-9]$" } } } },
            { no: 4, name: "subject", kind: "message", T: () => SubjectReference, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<LookupResourcesRequest>): LookupResourcesRequest {
        const message = { resourceObjectType: "", permission: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupResourcesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupResourcesRequest): LookupResourcesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.Consistency consistency */ 1:
                    message.consistency = Consistency.internalBinaryRead(reader, reader.uint32(), options, message.consistency);
                    break;
                case /* string resource_object_type */ 2:
                    message.resourceObjectType = reader.string();
                    break;
                case /* string permission */ 3:
                    message.permission = reader.string();
                    break;
                case /* authzed.api.v1.SubjectReference subject */ 4:
                    message.subject = SubjectReference.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupResourcesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.Consistency consistency = 1; */
        if (message.consistency)
            Consistency.internalBinaryWrite(message.consistency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string resource_object_type = 2; */
        if (message.resourceObjectType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceObjectType);
        /* string permission = 3; */
        if (message.permission !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.permission);
        /* authzed.api.v1.SubjectReference subject = 4; */
        if (message.subject)
            SubjectReference.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupResourcesRequest
 */
export const LookupResourcesRequest = new LookupResourcesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LookupResourcesResponse$Type extends MessageType<LookupResourcesResponse> {
    constructor() {
        super("authzed.api.v1.LookupResourcesResponse", [
            { no: 1, name: "looked_up_at", kind: "message", T: () => ZedToken },
            { no: 2, name: "resource_object_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LookupResourcesResponse>): LookupResourcesResponse {
        const message = { resourceObjectId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LookupResourcesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LookupResourcesResponse): LookupResourcesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* authzed.api.v1.ZedToken looked_up_at */ 1:
                    message.lookedUpAt = ZedToken.internalBinaryRead(reader, reader.uint32(), options, message.lookedUpAt);
                    break;
                case /* string resource_object_id */ 2:
                    message.resourceObjectId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LookupResourcesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* authzed.api.v1.ZedToken looked_up_at = 1; */
        if (message.lookedUpAt)
            ZedToken.internalBinaryWrite(message.lookedUpAt, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string resource_object_id = 2; */
        if (message.resourceObjectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.resourceObjectId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message authzed.api.v1.LookupResourcesResponse
 */
export const LookupResourcesResponse = new LookupResourcesResponse$Type();
/**
 * @generated ServiceType for protobuf service authzed.api.v1.PermissionsService
 */
export const PermissionsService = new ServiceType("authzed.api.v1.PermissionsService", [
    { name: "ReadRelationships", serverStreaming: true, options: { "google.api.http": { body: "*", post: "/v1/relationships/read" } }, I: ReadRelationshipsRequest, O: ReadRelationshipsResponse },
    { name: "WriteRelationships", options: { "google.api.http": { body: "*", post: "/v1/relationships/write" } }, I: WriteRelationshipsRequest, O: WriteRelationshipsResponse },
    { name: "DeleteRelationships", options: { "google.api.http": { body: "*", post: "/v1/relationships/delete" } }, I: DeleteRelationshipsRequest, O: DeleteRelationshipsResponse },
    { name: "CheckPermission", options: { "google.api.http": { body: "*", post: "/v1/permissions/check" } }, I: CheckPermissionRequest, O: CheckPermissionResponse },
    { name: "ExpandPermissionTree", options: { "google.api.http": { body: "*", post: "/v1/permissions/expand" } }, I: ExpandPermissionTreeRequest, O: ExpandPermissionTreeResponse },
    { name: "LookupResources", serverStreaming: true, options: { "google.api.http": { body: "*", post: "/v1/permissions/resources" } }, I: LookupResourcesRequest, O: LookupResourcesResponse }
]);
